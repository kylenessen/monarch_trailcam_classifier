<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.549">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Kyle Nessen">

<title>Test title</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="index_files/libs/clipboard/clipboard.min.js"></script>
<script src="index_files/libs/quarto-html/quarto.js"></script>
<script src="index_files/libs/quarto-html/popper.min.js"></script>
<script src="index_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="index_files/libs/quarto-html/anchor.min.js"></script>
<link href="index_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="index_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="index_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="index_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="index_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#overview" id="toc-overview" class="nav-link active" data-scroll-target="#overview">Overview</a></li>
  <li><a href="#getting-started" id="toc-getting-started" class="nav-link" data-scroll-target="#getting-started">Getting Started</a>
  <ul class="collapse">
  <li><a href="#basic-controls" id="toc-basic-controls" class="nav-link" data-scroll-target="#basic-controls">Basic Controls</a></li>
  <li><a href="#count-categories" id="toc-count-categories" class="nav-link" data-scroll-target="#count-categories">Count Categories</a></li>
  </ul></li>
  <li><a href="#classification-process" id="toc-classification-process" class="nav-link" data-scroll-target="#classification-process">Classification Process</a>
  <ul class="collapse">
  <li><a href="#initial-assessment" id="toc-initial-assessment" class="nav-link" data-scroll-target="#initial-assessment">1. Initial Assessment</a></li>
  <li><a href="#dense-cluster-protocol" id="toc-dense-cluster-protocol" class="nav-link" data-scroll-target="#dense-cluster-protocol">2. Dense Cluster Protocol</a></li>
  <li><a href="#medium-density-areas" id="toc-medium-density-areas" class="nav-link" data-scroll-target="#medium-density-areas">3. Medium Density Areas</a></li>
  <li><a href="#scanning-for-singles" id="toc-scanning-for-singles" class="nav-link" data-scroll-target="#scanning-for-singles">4. Scanning for Singles</a></li>
  <li><a href="#border-cases" id="toc-border-cases" class="nav-link" data-scroll-target="#border-cases">5. Border Cases</a></li>
  <li><a href="#sunlight-labeling" id="toc-sunlight-labeling" class="nav-link" data-scroll-target="#sunlight-labeling">6. Sunlight Labeling</a></li>
  </ul></li>
  <li><a href="#best-practices" id="toc-best-practices" class="nav-link" data-scroll-target="#best-practices">Best Practices</a>
  <ul class="collapse">
  <li><a href="#speed-vs.-accuracy" id="toc-speed-vs.-accuracy" class="nav-link" data-scroll-target="#speed-vs.-accuracy">Speed vs.&nbsp;Accuracy</a></li>
  <li><a href="#required-steps-before-moving-on" id="toc-required-steps-before-moving-on" class="nav-link" data-scroll-target="#required-steps-before-moving-on">Required Steps Before Moving On</a></li>
  </ul></li>
  <li><a href="#common-scenarios-and-solutions" id="toc-common-scenarios-and-solutions" class="nav-link" data-scroll-target="#common-scenarios-and-solutions">Common Scenarios and Solutions</a></li>
  </ul>
</nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Test title</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Kyle Nessen </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="overview" class="level2">
<h2 class="anchored" data-anchor-id="overview">Overview</h2>
<p>This guide provides instructions for using Monarch Image Labeler to estimate monarch butterfly numbers in gridded images. The goal is to efficiently categorize butterfly counts while maintaining consistency across different observers.</p>
</section>
<section id="getting-started" class="level2">
<h2 class="anchored" data-anchor-id="getting-started">Getting Started</h2>
<section id="basic-controls" class="level3">
<h3 class="anchored" data-anchor-id="basic-controls">Basic Controls</h3>
<ul>
<li>Use <code>S</code> or <code>→</code>to go to next photo</li>
<li>Use <code>A</code> or <code>←</code> to go to previous photo</li>
<li>Use <code>Space</code> to zoom in 300% for detailed inspection</li>
<li>Press <code>W</code> or click “Confirm Image” to save and proceed</li>
<li>Press <code>S</code> to copy classifications from previous image</li>
<li>Use <code>N</code> to toggle notes for unusual circumstances</li>
<li>“Switch to Color” button toggles between B&amp;W and color views</li>
<li>Keyboard shortcuts can be referenced anytime from the button in the top right.</li>
</ul>
</section>
<section id="count-categories" class="level3">
<h3 class="anchored" data-anchor-id="count-categories">Count Categories</h3>
<p>Each grid cell is categorized by the number of butterflies present:</p>
<ul>
<li>0 (Default): No butterflies (No color)</li>
<li>1-9: Single digits (Yellow)</li>
<li>10-99: Dozens (Orange)</li>
<li>100-999: Hundreds (Red)</li>
<li>1000+: Thousands (Purple)</li>
</ul>
<p>[INSERT: Example image showing different colored cells with corresponding counts]</p>
</section>
</section>
<section id="classification-process" class="level2">
<h2 class="anchored" data-anchor-id="classification-process">Classification Process</h2>
<section id="initial-assessment" class="level3">
<h3 class="anchored" data-anchor-id="initial-assessment">1. Initial Assessment</h3>
<ol type="1">
<li>Begin with the most densely populated cells</li>
<li>Use Space-bar zoom (300%) to inspect unclear areas</li>
<li>All cells start as 0 (uncolored) by default</li>
</ol>
</section>
<section id="dense-cluster-protocol" class="level3">
<h3 class="anchored" data-anchor-id="dense-cluster-protocol">2. Dense Cluster Protocol</h3>
<p>For cells with large clusters:</p>
<ul>
<li>If butterflies clearly exceed 100, classify as hundreds (red)</li>
<li>For dense clusters where butterflies may be obscured, apply a 1.3X multiplier</li>
<li>Example: If you can count ~80 butterflies in a dense cluster, multiply by 1.3 = 104, classify as hundreds</li>
<li>Only apply this multiplier when butterflies are likely obscured in dense clusters</li>
</ul>
<p>[INSERT: Animation/images showing dense cluster assessment]</p>
</section>
<section id="medium-density-areas" class="level3">
<h3 class="anchored" data-anchor-id="medium-density-areas">3. Medium Density Areas</h3>
<ul>
<li>If more than a few butterflies but not obviously hundreds, classify as dozens (orange)</li>
<li>No need to get exact counts - if you can quickly count &lt;10, it’s yellow; if it takes longer, it’s likely orange</li>
</ul>
</section>
<section id="scanning-for-singles" class="level3">
<h3 class="anchored" data-anchor-id="scanning-for-singles">4. Scanning for Singles</h3>
<ul>
<li>After marking dense areas, scan for isolated butterflies or small groups</li>
<li>Include both flying and roosting butterflies</li>
<li>For 1-9 butterflies, mark as yellow</li>
</ul>
</section>
<section id="border-cases" class="level3">
<h3 class="anchored" data-anchor-id="border-cases">5. Border Cases</h3>
<p>When clusters cross grid lines: - Only count butterflies within the current cell - Round up when in doubt - Some double-counting at borders is acceptable given the coarse estimation scale</p>
<p>[INSERT: Example of border case handling]</p>
</section>
<section id="sunlight-labeling" class="level3">
<h3 class="anchored" data-anchor-id="sunlight-labeling">6. Sunlight Labeling</h3>
<ul>
<li>For cells containing butterflies, note if they are in full sun</li>
<li>Only label sun exposure for cells that contain butterflies</li>
<li>Use F + Click to toggle sunlight for a cell</li>
</ul>
</section>
</section>
<section id="best-practices" class="level2">
<h2 class="anchored" data-anchor-id="best-practices">Best Practices</h2>
<section id="speed-vs.-accuracy" class="level3">
<h3 class="anchored" data-anchor-id="speed-vs.-accuracy">Speed vs.&nbsp;Accuracy</h3>
<ul>
<li>Prioritize efficiency over precise counts</li>
<li>When uncertain between categories, round up</li>
<li>The goal is order-of-magnitude estimation</li>
<li>Don’t spend excessive time on exact counts</li>
</ul>
</section>
<section id="required-steps-before-moving-on" class="level3">
<h3 class="anchored" data-anchor-id="required-steps-before-moving-on">Required Steps Before Moving On</h3>
<ol start="4" type="1">
<li>Ensure username is entered</li>
<li>Complete all cell classifications</li>
<li>Mark sunlight exposure where applicable</li>
<li>Add notes if necessary (blue button indicates notes present)</li>
<li>Confirm image to save and proceed</li>
</ol>
<p>[INSERT: Screenshot of completed image with various classifications]</p>
</section>
</section>
<section id="common-scenarios-and-solutions" class="level2">
<h2 class="anchored" data-anchor-id="common-scenarios-and-solutions">Common Scenarios and Solutions</h2>
<p>[This section will be populated with specific examples based on your image collection]</p>
<hr>
<p><em>Note: This documentation will be enhanced with relevant images and animations to illustrate key concepts and procedures.</em></p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>